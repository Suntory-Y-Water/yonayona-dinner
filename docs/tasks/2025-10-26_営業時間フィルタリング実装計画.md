# タスク 4.1, 4.2, 4.3: 営業時間フィルタリング機能の実装

## 概要

設計原則に基づき、営業時間判定ロジック、営業中店舗フィルタリング、閉店までの残り時間計算機能を実装します。すべての関数は純粋関数として実装し、副作用を持たないようにします。

## 要件

- タスク 4.1: 営業時間判定ロジックの構築
- タスク 4.2: 営業中店舗フィルタリング機能
- タスク 4.3: 閉店までの残り時間計算機能

## 実装チェックリスト

### 1. 型定義の追加

- [ ] 1.1 `shared/src/types/index.ts` に `FilteredPlace` 型を追加
  - `Place & { remainingMinutes: number }` の型定義
  - Zodスキーマ `FilteredPlaceSchema` を定義
  - TSDocコメントを追加（例を含む）
- [ ] 1.2 `FilteredPlacesResponse` 型を追加
  - `{ places: FilteredPlace[] }` の型定義
  - Zodスキーマ `FilteredPlacesResponseSchema` を定義
  - TSDocコメントを追加
- [ ] 1.3 型定義をexport
- [ ] 1.4 `AGENT=1 bun test --bail=2` でテストが通ることを確認

### 2. Domain Serviceの実装（営業時間判定ロジック）

- [ ] 2.1 `server/src/domain/opening-hours/` ディレクトリを作成
- [ ] 2.2 `server/src/domain/opening-hours/is-open-at.ts` を作成
  - `isOpenAt({ openingHours, targetTime }: { openingHours: OpeningHours | undefined; targetTime: Date }): boolean` 関数を実装
  - 事前条件:
    - `targetTime` は有効なDateオブジェクト
  - 事後条件:
    - `openingHours` が `undefined` の場合は `false` を返す
    - 営業中の場合は `true`、閉店中の場合は `false` を返す
  - 24時跨ぎ営業時間に対応（例: 23:30–翌5:00）
  - 複数営業時間スロットに対応（例: 11:00-14:00と17:00-23:00）
  - TSDocコメントを追加（使用例を含む）
- [ ] 2.3 `server/src/domain/opening-hours/is-open-at.test.ts` を作成
  - Given-When-Thenパターンでテストを実装
  - テストケース:
    - 営業時間情報なし（undefined）の場合は false
    - 通常営業時間内（例: 18:00-23:00、現在20:00）は true
    - 営業時間外（例: 18:00-23:00、現在15:00）は false
    - 24時跨ぎ営業時間内（例: 23:30-翌5:00、現在1:00）は true
    - 24時跨ぎ営業時間外（例: 23:30-翌5:00、現在10:00）は false
    - 複数営業時間スロット（例: 11:00-14:00と17:00-23:00、現在12:00）は true
    - 複数営業時間スロット（例: 11:00-14:00と17:00-23:00、現在15:00）は false
    - 閉店時刻ちょうど（例: 23:00閉店、現在23:00）は false
    - 開店時刻ちょうど（例: 18:00開店、現在18:00）は true
- [ ] 2.4 `AGENT=1 bun test --bail=2` でテストが通ることを確認

### 3. 営業中店舗フィルタリング機能の実装

- [ ] 3.1 `server/src/domain/opening-hours/filter-open-places.ts` を作成
  - `filterOpenPlaces({ places, targetTime }: { places: Place[]; targetTime: Date }): Place[]` 関数を実装
  - 事前条件:
    - `places` は空配列または有効な店舗情報の配列
    - `targetTime` は有効なDateオブジェクト
  - 事後条件:
    - 営業時間情報が存在し、かつ営業中の店舗のみを含む配列を返す
    - 元の配列は変更しない（イミュータブル）
  - `isOpenAt()` を使用してフィルタリング
  - TSDocコメントを追加（使用例を含む）
- [ ] 3.2 `server/src/domain/opening-hours/filter-open-places.test.ts` を作成
  - Given-When-Thenパターンでテストを実装
  - テストケース:
    - 空配列の場合は空配列を返す
    - すべて営業中の場合はすべて返す
    - すべて閉店中の場合は空配列を返す
    - 一部営業中の場合は営業中のみ返す
    - 営業時間情報なしの店舗は除外される
    - 元の配列が変更されないことを確認
- [ ] 3.3 `AGENT=1 bun test --bail=2` でテストが通ることを確認

### 4. 閉店までの残り時間計算機能の実装

- [ ] 4.1 `server/src/domain/opening-hours/calculate-remaining-minutes.ts` を作成
  - `calculateRemainingMinutes({ openingHours, currentTime }: { openingHours: OpeningHours; currentTime: Date }): number | null` 関数を実装
  - 事前条件:
    - `openingHours.periods` は空でない配列
    - `currentTime` は有効なDateオブジェクト
  - 事後条件:
    - 営業中の場合、閉店までの残り時間を分単位で返す
    - 営業時間外の場合は `null` を返す
  - 24時跨ぎ営業での残り時間計算に対応
  - TSDocコメントを追加（使用例を含む）
- [ ] 4.2 `server/src/domain/opening-hours/calculate-remaining-minutes.test.ts` を作成
  - Given-When-Thenパターンでテストを実装
  - テストケース:
    - 営業中（例: 18:00-23:00、現在20:00）は180分を返す
    - 営業中（例: 18:00-23:00、現在22:30）は30分を返す
    - 営業時間外（例: 18:00-23:00、現在15:00）は null を返す
    - 24時跨ぎ営業中（例: 23:30-翌5:00、現在1:00）は240分を返す
    - 閉店1分前（例: 23:00閉店、現在22:59）は1分を返す
    - 閉店時刻ちょうど（例: 23:00閉店、現在23:00）は null を返す
- [ ] 4.3 `AGENT=1 bun test --bail=2` でテストが通ることを確認

### 5. FilteredPlaceへの変換関数の実装

- [ ] 5.1 `server/src/domain/opening-hours/to-filtered-place.ts` を作成
  - `toFilteredPlace({ place, targetTime }: { place: Place; targetTime: Date }): FilteredPlace` 関数を実装
  - 事前条件:
    - `place` は有効な店舗情報
    - `targetTime` は有効なDateオブジェクト
  - 事後条件:
    - `Place` に `remainingMinutes` を追加した `FilteredPlace` を返す
    - 営業時間情報がない、または営業時間外の場合は `remainingMinutes: 0` を返す
  - `calculateRemainingMinutes()` を使用
  - TSDocコメントを追加（使用例を含む）
- [ ] 5.2 `server/src/domain/opening-hours/to-filtered-place.test.ts` を作成
  - Given-When-Thenパターンでテストを実装
  - テストケース:
    - 営業中の店舗は正しい残り時間を持つ
    - 営業時間外の店舗は remainingMinutes: 0
    - 営業時間情報なしの店舗は remainingMinutes: 0
    - 元のPlaceオブジェクトのすべてのプロパティが保持される
- [ ] 5.3 `AGENT=1 bun test --bail=2` でテストが通ることを確認

### 7. Usecaseの更新

- [ ] 7.1 `server/src/usecases/search-nearby-places.usecase.ts` を更新
  - `FilteredPlacesResponse` 型をimport
  - `execute()` の戻り値を `Result<FilteredPlacesResponse, PlacesAPIError>` に変更
  - `filterOpenPlaces()` と `toFilteredPlace()` をimport
  - 検索結果に対してフィルタリングと変換を適用:
    1. `filterOpenPlaces({ places: searchResult.data, targetTime })` で営業中店舗のみフィルタリング
    2. フィルタリング後の各店舗に `toFilteredPlace({ place, targetTime })` を適用
  - `targetTime` パラメータを `SearchNearbyRequest` に追加（現在時刻を受け取る）
- [ ] 7.2 `server/src/usecases/search-nearby-places.usecase.test.ts` を更新
  - 営業中店舗のみ返されることを確認するテストを追加
  - 営業時間情報なし店舗が除外されることを確認するテストを追加
  - `remainingMinutes` が正しく計算されることを確認するテストを追加
- [ ] 7.3 `AGENT=1 bun test --bail=2` でテストが通ることを確認

### 8. 型定義の更新（targetTimeパラメータ追加）

- [ ] 8.1 `shared/src/types/index.ts` の `SearchNearbyRequest` に `targetTime` を追加
  - `targetTime: Date` フィールドを追加
  - Zodスキーマを更新（`z.date()` または `z.string().transform()` で ISO 8601 文字列を受け取る）
  - TSDocコメントを更新
- [ ] 8.2 `AGENT=1 bun test --bail=2` でテストが通ることを確認

### 9. Honoルーターの更新

- [ ] 9.1 `server/src/index.ts` を更新
  - `/api/places/search` エンドポイントのリクエストボディに `targetTime` を追加
  - 現在は `targetTime` をリクエストボディから受け取る（将来的にクライアント側で時間調整UIを実装するため）
  - バリデーションを追加（ISO 8601形式の文字列を `Date` オブジェクトに変換）
  - Usecaseに `targetTime` を渡す
- [ ] 9.2 レスポンス型を `FilteredPlacesResponse` に変更
- [ ] 9.3 `bun run build` でビルドが通ることを確認

### 10. 統合テストとドキュメント

- [ ] 10.1 すべてのユニットテストを実行（`AGENT=1 bun test --bail=2`）
- [ ] 10.2 型チェックとリントを実行（`bun run ai-check`）
- [ ] 10.3 ビルドを実行（`bun run build`）
- [ ] 10.4 実装完了を `docs/shared/2025-10-19_tasks.md` に反映
  - タスク 4.1, 4.2, 4.3 をチェック済みにする

## 技術仕様

### 営業時間判定アルゴリズム

#### 1. 現在の曜日・時刻を取得

```typescript
const currentDay = targetTime.getDay(); // 0=日曜, 6=土曜
const currentHour = targetTime.getHours();
const currentMinute = targetTime.getMinutes();
```

#### 2. 各営業時間帯で営業中かチェック

#### 3. 閉店までの残り時間計算

```typescript
// 営業中の営業時間帯を見つける
const currentPeriod = openingHours.periods.find(period =>
  isOpenAtPeriod({ period, targetTime })
);

if (!currentPeriod) return null;

// 閉店時刻までの分数を計算
const closeTime = new Date(targetTime);
closeTime.setDate(/* close.day に基づいて日付を設定 */);
closeTime.setHours(currentPeriod.close.hour);
closeTime.setMinutes(currentPeriod.close.minute);
closeTime.setSeconds(0);
closeTime.setMilliseconds(0);

const diffMs = closeTime.getTime() - targetTime.getTime();
return Math.floor(diffMs / 60 * 1000); // ミリ秒を分に変換
```

### API仕様

#### リクエスト

```json
{
  "location": { "lat": 35.6812, "lng": 139.7671 },
  "radius": 800,
  "targetTime": "2025-10-26T23:00:00+09:00"
}
```

#### レスポンス

```json
{
  "places": [
    {
      "id": "ChIJ...",
      "displayName": "居酒屋 example",
      "location": { "lat": 35.6812, "lng": 139.7671 },
      "formattedAddress": "東京都...",
      "currentOpeningHours": {
        "openNow": true,
        "periods": [
          {
            "open": { "day": 1, "hour": 18, "minute": 0 },
            "close": { "day": 2, "hour": 2, "minute": 0 }
          }
        ],
        "weekdayDescriptions": ["月曜日: 18:00～翌2:00"]
      },
      "rating": 4.5,
      "remainingMinutes": 180
    }
  ]
}
```

### エラーハンドリング

- 営業時間情報なし: フィルタリング時に除外
- 営業時間外: フィルタリング時に除外
- 不正な `targetTime`: UsecaseでINVALID_REQUESTエラーを返す

### テスト戦略

- すべての関数は純粋関数として実装
- Given-When-Thenパターンでテストを記述
- エッジケース（24時跨ぎ、複数スロット、境界値）を網羅
- TDD: テストを先に書いて実装を行う

## 参考資料

- [設計ドキュメント - バックエンドコンポーネント](../design/design_バックエンドコンポーネント.md)
- [設計ドキュメント - 共通層とデータモデル](../design/design_共通層とデータモデル.md)
- [date-fns ドキュメント](https://date-fns.org/docs/Getting-Started)

## 実装上の注意事項

1. **純粋関数の原則を守る**
   - すべての関数は副作用を持たない
   - 引数のオブジェクトを変更しない（イミュータブル）
   - 同じ入力に対して常に同じ出力を返す

2. **型安全性を確保**
   - すべての関数に適切な型定義を付ける
   - Zodスキーマで実行時バリデーションを行う

3. **コーディング規約を遵守**
   - 関数の引数が2個以上の場合はオブジェクト形式で受け取る
   - 最上位の関数は `function` 宣言で実装
   - 配列の型定義は `Array<T>` ではなく `T[]` を使用
   - すべての関数にTSDocコメント（使用例を含む）を追加

4. **テスト方針を守る**
   - Given-When-Thenパターンで実装
   - 事前条件、事後条件、不変条件を検証
   - TDDで実装（テストを先に書く）
   - `AGENT=1 bun test --bail=2` で各ステップ後に確認
